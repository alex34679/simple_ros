# 可视化模块

## 1. 可视化模块概述

simple_ros系统的可视化模块提供了与Foxglove Studio集成的功能，允许用户以图形化方式查看和分析机器人系统的数据。该模块主要基于Foxglove Bridge实现，支持发布各种类型的可视化标记、路径和数据图表等。

### 1.1 功能特点

- 支持发布多种类型的可视化标记（Marker），如点、线、面、立方体、球体等
- 支持发布标记数组（MarkerArray），可同时显示多个标记
- 支持发布路径可视化数据
- 支持发布机器人模型和传感器数据的可视化
- 提供与Foxglove Studio的无缝集成
- 支持实时数据更新和交互

### 1.2 应用场景

- 机器人状态监控
- 路径规划与跟踪可视化
- 传感器数据可视化（如激光雷达点云、相机图像）
- 机器人运动规划和控制算法调试
- 系统性能分析和故障排查

## 2. Foxglove Bridge

Foxglove Bridge是连接simple_ros系统和Foxglove Studio的桥梁，它负责将系统中的数据转发到Foxglove Studio进行可视化展示。

### 2.1 编译和启用Foxglove Bridge

在CMakeLists.txt中，Foxglove Bridge是一个可选模块，可以通过设置`ENABLE_FOXGLOVE`宏来启用或禁用：

```cpp
option(ENABLE_FOXGLOVE "Enable Foxglove Bridge" ON)

if(ENABLE_FOXGLOVE)
    # 添加Foxglove Bridge相关的源文件和链接库
    # ...
endif()
```

### 2.2 启动Foxglove Bridge

系统提供了`foxglove_bridge_tool`工具程序，可以直接启动Foxglove Bridge：

```bash
./build/bin/toolsfoxglove_bridge_tool
```

### 2.3 连接Foxglove Studio

1. 启动Foxglove Studio应用程序或访问[Foxglove Studio网页版](https://studio.foxglove.dev/)
2. 点击"Open Connection"按钮
3. 选择"Foxglove WebSocket"选项
4. 输入WebSocket服务器地址，默认为`ws://localhost:8765`
5. 点击"Connect"按钮，连接到Foxglove Bridge

## 3. 可视化标记（Marker）

Marker是最常用的可视化元素，可以表示各种形状和对象。

### 3.1 Marker消息结构

Marker消息包含以下主要字段：

- `header`：消息头，包含时间戳和坐标系
- `ns`：命名空间，用于区分不同类型的标记
- `id`：标记的唯一标识符
- `type`：标记类型（如点、线、立方体、球体等）
- `action`：操作类型（添加、修改、删除）
- `pose`：标记的位置和姿态
- `scale`：标记的大小
- `color`：标记的颜色
- `lifetime`：标记的生命周期
- `points`：点的集合（用于线、多边形等类型）
- `text`：文本内容（用于文本类型）

### 3.2 Marker类型

系统支持以下常见的Marker类型：

- `CUBE`：立方体
- `CYLINDER`：圆柱体
- `LINE_LIST`：线列表


### 3.3 发布Marker消息

以下是发布一个立方体标记的示例：

```cpp
// 创建NodeHandle
NodeHandle nh;

// 创建Marker发布者
auto marker_pub = nh.advertise<visualization_msgs::Marker>("visualization_marker");

// 创建并填充Marker消息
visualization_msgs::Marker marker;
marker.mutable_header()->set_frame_id("map");
marker.mutable_header()->set_stamp(SystemManager::instance().now().sec);
marker.set_ns("basic_shapes");
marker.set_id(0);
marker.set_type(visualization_msgs::MarkerType::CUBE);
marker.set_action(visualization_msgs::MarkerAction::ADD);

// 设置位置和姿态
marker.mutable_pose()->mutable_position()->set_x(0.0);
marker.mutable_pose()->mutable_position()->set_y(0.0);
marker.mutable_pose()->mutable_position()->set_z(0.0);
marker.mutable_pose()->mutable_orientation()->set_x(0.0);
marker.mutable_pose()->mutable_orientation()->set_y(0.0);
marker.mutable_pose()->mutable_orientation()->set_z(0.0);
marker.mutable_pose()->mutable_orientation()->set_w(1.0);

// 设置大小
marker.mutable_scale()->set_x(1.0);
marker.mutable_scale()->set_y(1.0);
marker.mutable_scale()->set_z(1.0);

// 设置颜色（RGBA格式）
marker.mutable_color()->set_r(0.0);
marker.mutable_color()->set_g(1.0);
marker.mutable_color()->set_b(0.0);
marker.mutable_color()->set_a(1.0);

// 设置生命周期（-1表示永久存在）
marker.set_lifetime(-1);

// 发布消息
marker_pub->publish(marker);
```

## 4. 标记数组（MarkerArray）

MarkerArray用于同时发布多个标记，适用于需要显示复杂场景或多个相关对象的情况。

### 4.1 MarkerArray消息结构

MarkerArray消息包含一个Marker类型的数组：

```cpp
message MarkerArray {
  repeated Marker markers = 1;
}
```

### 4.2 发布MarkerArray消息

以下是发布一个包含多个标记的MarkerArray示例：

```cpp
// 创建MarkerArray发布者
auto marker_array_pub = nh.advertise<visualization_msgs::MarkerArray>("visualization_marker_array");

// 创建MarkerArray消息
visualization_msgs::MarkerArray marker_array;

// 添加第一个标记（立方体）
visualization_msgs::Marker cube_marker;
cube_marker.mutable_header()->set_frame_id("map");
cube_marker.mutable_header()->set_stamp(SystemManager::instance().now().sec);
cube_marker.set_ns("shapes");
cube_marker.set_id(0);
cube_marker.set_type(visualization_msgs::MarkerType::CUBE);
cube_marker.set_action(visualization_msgs::MarkerAction::ADD);
// 设置其他属性...
*marker_array.add_markers() = cube_marker;

// 添加第二个标记（球体）
visualization_msgs::Marker sphere_marker;
sphere_marker.mutable_header()->set_frame_id("map");
sphere_marker.mutable_header()->set_stamp(SystemManager::instance().now().sec);
sphere_marker.set_ns("shapes");
sphere_marker.set_id(1);
sphere_marker.set_type(visualization_msgs::MarkerType::SPHERE);
sphere_marker.set_action(visualization_msgs::MarkerAction::ADD);
// 设置其他属性...
*marker_array.add_markers() = sphere_marker;

// 发布消息
marker_array_pub->publish(marker_array);
```

## 5. 路径可视化

路径可视化用于显示机器人的运动路径或规划路径，通常使用LINE_STRIP类型的Marker。

### 5.1 发布路径可视化

以下是发布路径可视化的示例：

```cpp
// 创建路径发布者
auto path_pub = nh.advertise<visualization_msgs::Marker>("path");

// 创建路径Marker
visualization_msgs::Marker path_marker;
path_marker.mutable_header()->set_frame_id("map");
path_marker.mutable_header()->set_stamp(SystemManager::instance().now().sec);
path_marker.set_ns("path");
path_marker.set_id(0);
path_marker.set_type(visualization_msgs::MarkerType::LINE_STRIP);
path_marker.set_action(visualization_msgs::MarkerAction::ADD);
path_marker.set_lifetime(-1); // 永久存在

// 设置颜色和线宽
path_marker.mutable_color()->set_r(1.0);
path_marker.mutable_color()->set_g(0.0);
path_marker.mutable_color()->set_b(0.0);
path_marker.mutable_color()->set_a(1.0);
path_marker.mutable_scale()->set_x(0.1); // 线宽

// 添加路径点
std::vector<geometry_msgs::Point> path_points;
// 假设已经填充了path_points

for (const auto& point : path_points) {
    geometry_msgs::Point* p = path_marker.add_points();
    p->set_x(point.x());
    p->set_y(point.y());
    p->set_z(point.z());
}

// 发布消息
path_pub->publish(path_marker);
```

## 6. 机器人模型可视化

当前仅支持适用基础模型拼接机器人模型。


### 7 数据可视化面板

Foxglove Studio提供了多种数据可视化面板，如曲线图、散点图、仪表盘等，可以用于显示和分析传感器数据、控制信号等：

```cpp
// 发布用于曲线图显示的数据
auto plot_pub = nh.advertise<std_msgs::Float64>("temperature");

std_msgs::Float64 temperature;
temperature.set_data(current_temperature);
plot_pub->publish(temperature);

// 在Foxglove Studio中，可以添加曲线图面板，并选择"temperature"主题进行显示
```

## 8. 最佳实践

### 8.1 性能优化

- 使用合适的生命周期：对于动态更新的对象，设置合理的生命周期，避免过多的删除和创建操作
- 批量发布：使用MarkerArray批量发布多个标记，减少通信开销
- 降低更新频率：根据实际需求，适当降低可视化元素的更新频率
- 减少数据量：对于点云等大数据量的可视化，考虑降采样或过滤

### 8.2 可视化设计

- 颜色编码：使用不同的颜色表示不同类型的对象或状态
- 层次结构：使用不同的命名空间和ID组织可视化元素
- 坐标系：使用一致的坐标系，避免混淆
- 图例：为复杂的可视化场景提供图例说明

### 8.3 调试技巧

- 使用临时标记：在调试过程中，可以发布临时标记来标记特定位置或事件
- 日志可视化：将系统日志发布为文本标记，便于在可视化界面中查看
- 状态反馈：使用颜色或形状变化来表示系统状态的变化



## 9. 示例代码

系统提供了多个可视化相关的示例代码，位于`examples`目录下，包括：

- `marker_publisher_example.cpp`：展示如何发布各种类型的Marker
- `quad_visualizer_node.cpp`：四旋翼无人机可视化示例
- `path_visualization_example.cpp`：路径可视化示例

这些示例代码可以帮助用户快速上手可视化功能，理解如何在自己的应用中使用可视化模块。